package main

import (
	"context"
	"errors"
	"flag"
	"fmt"
	"log"
	"net/url"
	"os"
	"os/signal"
	"strconv"
	"time"

	opampinternal "github.com/open-telemetry/opamp-go/internal"
	"github.com/open-telemetry/opamp-go/internal/examples/agent/agent"
	"github.com/open-telemetry/opamp-go/internal/examples/config"

	"github.com/google/uuid"
	"go.opentelemetry.io/collector/config/configtls"
	"go.opentelemetry.io/otel"
)

// nopErrorHandler is used to turn any otel errors generated by scale agents into a nop.
type nopErrorHandler struct{}

func (l *nopErrorHandler) Handle(err error) {}

// scaleConfig are all the flags/env vars that can be used to configure the scale test driver.
type scaleConfig struct {
	agentCount            uint64
	serverURL             string
	heartbeat             time.Duration
	verboseAgents         bool
	tlsInsecure           bool
	tlsInsecureSkipVerify bool
	tlsCAFile             string
}

// verifyArgs checks that all scaleConfig options are valid.
func (cfg scaleConfig) verifyArgs() error {
	if cfg.agentCount == 0 {
		return errors.New("agent count must not be zero")
	}
	parsedURL, err := url.Parse(cfg.serverURL)
	if err != nil {
		return fmt.Errorf("server-url failed to parse: %w", err)
	}
	switch parsedURL.Scheme {
	case "http", "https":
	case "ws", "wss":
	default:
		return fmt.Errorf("server-url has an unknown scheme: %s", parsedURL.Scheme)
	}

	if cfg.heartbeat < 0 {
		return fmt.Errorf("heartbeat must be non-negative, got: %s", cfg.heartbeat)
	}

	if cfg.tlsCAFile != "" {
		fi, err := os.Stat(cfg.tlsCAFile)
		if err != nil {
			return fmt.Errorf("tls-ca_file stat failed: %w", err)
		}
		if fi.IsDir() {
			return fmt.Errorf("tls-ca_file: %s is a directory", cfg.tlsCAFile)
		}
	}

	return nil
}

// loadEnv will attempt to load scaleConfig options from environment variables.
func loadEnv(cfg *scaleConfig) {
	if s, ok := os.LookupEnv("SCALE_AGENT_COUNT"); ok {
		count, err := strconv.ParseUint(s, 10, 64)
		if err == nil {
			cfg.agentCount = count
		}
	}

	if s, ok := os.LookupEnv("SCALE_SERVER_URL"); ok {
		cfg.serverURL = s
	}

	if s, ok := os.LookupEnv("SCALE_HEARTBEAT"); ok {
		dur, err := time.ParseDuration(s)
		if err == nil {
			cfg.heartbeat = dur
		}
	}

	if s, ok := os.LookupEnv("SCALE_VERBOSE_AGENTS"); ok {
		b, err := strconv.ParseBool(s)
		if err == nil {
			cfg.verboseAgents = b
		}
	}

	if s, ok := os.LookupEnv("SCALE_TLS_INSECURE"); ok {
		b, err := strconv.ParseBool(s)
		if err == nil {
			cfg.tlsInsecure = b
		}
	}

	if s, ok := os.LookupEnv("SCALE_TLS_INSECURE_SKIP_VERIFY"); ok {
		b, err := strconv.ParseBool(s)
		if err == nil {
			cfg.tlsInsecureSkipVerify = b
		}
	}

	if s, ok := os.LookupEnv("SCALE_TLS_CA_FILE"); ok {
		cfg.tlsCAFile = s
	}
}

// runAgents starts and returns the configured amount of agents.
// If an error is encountered when starting an agent, it is return along with all started agents.
func runAgents(ctx context.Context, cfg scaleConfig) ([]*agent.Agent, error) {
	nopLogger := &opampinternal.NopLogger{}
	agentConfig := &config.AgentConfig{
		Endpoint:          cfg.serverURL,
		HeartbeatInterval: &cfg.heartbeat,
		TLSSetting: configtls.ClientConfig{
			Insecure:           cfg.tlsInsecure,
			InsecureSkipVerify: cfg.tlsInsecureSkipVerify,
			Config: configtls.Config{
				CAFile: cfg.tlsCAFile,
			},
		},
	}

	// Use of slice instead of a concurrent goroutine to reduce memory usage.
	agents := make([]*agent.Agent, 0, cfg.agentCount)
	var err error
	for range cfg.agentCount {
		select {
		case <-ctx.Done():
			return agents, err
		default:
		}

		id, err := uuid.NewV7()
		if err != nil {
			return nil, err
		}

		opts := []agent.Option{
			agent.WithNoClientCertRequest(),
			agent.WithInstanceID(id),
		}

		if cfg.verboseAgents {
			opts = append(opts, agent.WithLogger(agent.NewScaleLogger(id)))
		} else {
			opts = append(opts, agent.WithLogger(nopLogger))
		}
		a := agent.NewAgent(agentConfig, opts...)
		if startErr := a.Start(); err != nil {
			err = errors.Join(err, startErr)
			continue
		}
		agents = append(agents, a)
	}
	return agents, err
}

func main() {
	var cfg scaleConfig
	flag.Uint64Var(&cfg.agentCount, "agent-count", 1000, "The number of agents to start (env var: SCALE_AGENT_COUNT).")
	flag.StringVar(&cfg.serverURL, "server-url", "wss://127.0.0.1:4320/v1/opamp", "OpAMP server URL (env var: SCALE_SERVER_URL).")
	flag.DurationVar(&cfg.heartbeat, "heartbeat", time.Second*30, "Heartbeat duration (env var: SCALE_HEARTBEAT).")
	flag.BoolVar(&cfg.verboseAgents, "verbose-agents", false, "Enable agent logging (env var: SCALE_VERBOSE_AGENTS).")
	flag.BoolVar(&cfg.tlsInsecure, "tls-insecure", false, "Disable the client transport security (env var: SCALE_TLS_INSECURE).")
	flag.BoolVar(&cfg.tlsInsecureSkipVerify, "tls-insecure_skip_verify", false, "Will enable TLS but not verify the certificate (env var: SCALE_TLS_INSECURE_SKIP_VERIFY).")
	flag.StringVar(&cfg.tlsCAFile, "tls-ca_file", "", "Path to the OpAMP server CA cert (env var: SCALE_TLS_CA_FILE).")

	flag.Parse()
	loadEnv(&cfg)

	logger := log.New(os.Stdout, "scale-test: ", log.Ldate|log.Lmicroseconds|log.Lmsgprefix)
	if err := cfg.verifyArgs(); err != nil {
		logger.Fatalf("Arg verification error: %v", err)
	}

	ctx, cancel := signal.NotifyContext(context.Background(), os.Interrupt)
	defer cancel()

	// Silence the otel errors agents can generate.
	// i.e.: failed to upload metrics: ...
	if !cfg.verboseAgents {
		otel.SetErrorHandler(&nopErrorHandler{})
	}

	logger.Printf("Starting %d agents", cfg.agentCount)

	agents, err := runAgents(ctx, cfg)
	if err != nil {
		logger.Printf("Error starting agents: %v", err)
	}
	logger.Printf("%d agents started", len(agents))

	<-ctx.Done() // wait for SIGINT
	for _, a := range agents {
		a.Shutdown()
	}
	logger.Println("All agents stopped")
}
