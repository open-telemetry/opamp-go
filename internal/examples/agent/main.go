package main

import (
	"context"
	"errors"
	"flag"
	"fmt"
	"log"
	"net/url"
	"os"
	"os/signal"
	"strconv"
	"time"

	opampinternal "github.com/open-telemetry/opamp-go/internal"
	"github.com/open-telemetry/opamp-go/internal/examples/agent/agent"
	"github.com/open-telemetry/opamp-go/internal/examples/config"

	"github.com/google/uuid"
	"go.opentelemetry.io/collector/config/configtls"
	"go.opentelemetry.io/otel"
)

// nopErrorHandler is used to turn any otel errors generated by scale agents into a nop.
type nopErrorHandler struct{}

func (l *nopErrorHandler) Handle(err error) {}

// flagConfig are all the flags/env vars that can be used to configure the agent process
type flagConfig struct {
	// Agent config options
	agentType             string
	agentVersion          string
	tlsInsecure           bool
	tlsInsecureSkipVerify bool
	tlsCertFile           string
	tlsKeyFile            string
	tlsCAFile             string
	endpoint              string
	heartbeat             time.Duration
	quietAgent            bool
	// scaleCount = 1 runs a normal agent
	// scaleCount > 1 runs scale test agents (pre-assigned IDs, no initial cert request)
	scaleCount uint64
}

func (cfg flagConfig) verifyArgs() error {
	if cfg.tlsCertFile != "" {
		fi, err := os.Stat(cfg.tlsCertFile)
		if err != nil {
			return fmt.Errorf("tls-cert_file stat failed: %w", err)
		}
		if fi.IsDir() {
			return fmt.Errorf("tls-cert_file: %s is a directory", cfg.tlsCertFile)
		}
	}

	if cfg.tlsKeyFile != "" {
		fi, err := os.Stat(cfg.tlsKeyFile)
		if err != nil {
			return fmt.Errorf("tls-key_file stat failed: %w", err)
		}
		if fi.IsDir() {
			return fmt.Errorf("tls-key_file: %s is a directory", cfg.tlsKeyFile)
		}
	}

	if cfg.tlsCAFile != "" {
		fi, err := os.Stat(cfg.tlsCAFile)
		if err != nil {
			return fmt.Errorf("tls-ca_file stat failed: %w", err)
		}
		if fi.IsDir() {
			return fmt.Errorf("tls-ca_file: %s is a directory", cfg.tlsCAFile)
		}
	}

	parsedURL, err := url.Parse(cfg.endpoint)
	if err != nil {
		return fmt.Errorf("endpoint failed to parse: %w", err)
	}
	switch parsedURL.Scheme {
	case "http", "https":
	case "ws", "wss":
	default:
		return fmt.Errorf("endpoint has an unknown scheme: %s", parsedURL.Scheme)
	}

	if cfg.heartbeat < 0 {
		return fmt.Errorf("heartbeat must be non-negative, got: %s", cfg.heartbeat)
	}

	if cfg.scaleCount == 0 {
		return errors.New("scale count must not be zero")
	}
	return nil
}

// loadEnv will attempt to load config options from environment variables.
// used to specifiy options when running the agent in a container.
func loadEnv(cfg *flagConfig) {
	if s, ok := os.LookupEnv("AGENT_TYPE"); ok {
		cfg.agentType = s
	}

	if s, ok := os.LookupEnv("AGENT_VERSION"); ok {
		cfg.agentVersion = s
	}

	if s, ok := os.LookupEnv("AGENT_TLS_INSECURE"); ok {
		b, err := strconv.ParseBool(s)
		if err == nil {
			cfg.tlsInsecure = b
		}
	}

	if s, ok := os.LookupEnv("AGENT_TLS_INSECURE_SKIP_VERIFY"); ok {
		b, err := strconv.ParseBool(s)
		if err == nil {
			cfg.tlsInsecureSkipVerify = b
		}
	}

	if s, ok := os.LookupEnv("AGENT_TLS_CERT_FILE"); ok {
		cfg.tlsCertFile = s
	}

	if s, ok := os.LookupEnv("AGENT_TLS_KEY_FILE"); ok {
		cfg.tlsKeyFile = s
	}

	if s, ok := os.LookupEnv("AGENT_TLS_CA_FILE"); ok {
		cfg.tlsCAFile = s
	}

	if s, ok := os.LookupEnv("AGENT_ENDPOINT"); ok {
		cfg.endpoint = s
	}

	if s, ok := os.LookupEnv("AGENT_HEARTBEAT"); ok {
		dur, err := time.ParseDuration(s)
		if err == nil {
			cfg.heartbeat = dur
		}
	}

	if s, ok := os.LookupEnv("AGENT_QUIET"); ok {
		b, err := strconv.ParseBool(s)
		if err == nil {
			cfg.quietAgent = b
		}
	}

	if s, ok := os.LookupEnv("AGENT_SCALE_COUNT"); ok {
		count, err := strconv.ParseUint(s, 10, 64)
		if err == nil {
			cfg.scaleCount = count
		}
	}
}

func main() {
	var cfg flagConfig
	flag.StringVar(&cfg.agentType, "t", "io.opentelemetry.collector", "Agent Type String (env var: AGENT_TYPE).")
	flag.StringVar(&cfg.agentVersion, "v", "1.0.0", "Agent Version String (env var: AGENT_VERSION).")
	flag.BoolVar(&cfg.tlsInsecure, "tls-insecure", false, "Disable the client transport security (env var: AGENT_TLS_INSECURE).")
	flag.BoolVar(&cfg.tlsInsecureSkipVerify, "tls-insecure_skip_verify", false, "Will enable TLS but not verify the certificate (env var: AGENT_TLS_INSECURE_SKIP_VERIFY).")
	flag.StringVar(&cfg.tlsCertFile, "tls-cert_file", "", "Path to the TLS cert (env var: AGENT_TLS_CERT_FILE).")
	flag.StringVar(&cfg.tlsKeyFile, "tls-key_file", "", "Path to the TLS key (env var: AGENT_TLS_KEY_FILE).")
	flag.StringVar(&cfg.tlsCAFile, "tls-ca_file", "", "Path to the CA cert. It verifies the server certificate (env var: AGENT_TLS_CA_FILE).")
	flag.StringVar(&cfg.endpoint, "endpoint", "wss://127.0.0.1:4320/v1/opamp", "OpAMP server endpoint URL (env var: AGENT_ENDPOINT).")
	flag.DurationVar(&cfg.heartbeat, "heartbeat", time.Second*30, "Heartbeat duration (env var: AGENT_HEARTBEAT).")
	flag.BoolVar(&cfg.quietAgent, "quite-agent", false, "Disable agent logger (env var: AGENT_QUIET).")
	flag.Uint64Var(&cfg.scaleCount, "scale-count", 1, "The number of agents to start in scale mode (env var: AGENT_SCALE_COUNT).")

	flag.Parse()
	loadEnv(&cfg)

	logger := log.Default()
	if err := cfg.verifyArgs(); err != nil {
		logger.Fatalf("Arg verification error: %v", err)
	}

	if cfg.scaleCount > 1 {
		logger = log.New(os.Stdout, "scale-test: ", log.Ldate|log.Lmicroseconds|log.Lmsgprefix)
	}

	if cfg.quietAgent {
		// Silence the otel errors agents can generate.
		// i.e.: failed to upload metrics: ...
		otel.SetErrorHandler(&nopErrorHandler{})
	}

	ctx, cancel := signal.NotifyContext(context.Background(), os.Interrupt)
	defer cancel()

	agents, err := runScale(ctx, cfg)
	if err != nil {
		logger.Printf("Error starting agents: %v", err)
	}
	logger.Printf("%d agents started", len(agents))

	<-ctx.Done()
	for _, a := range agents {
		a.Shutdown()
	}
	logger.Println("All agents stopped")
}

// runScale starts and returns the configured amount of agents.
// If an error is encountered when starting an agent, it is return along with all started agents.
func runScale(ctx context.Context, cfg flagConfig) ([]*agent.Agent, error) {
	nopLogger := &opampinternal.NopLogger{}
	agentConfig := &config.AgentConfig{
		Endpoint:          cfg.endpoint,
		HeartbeatInterval: &cfg.heartbeat,
		TLSSetting: configtls.ClientConfig{
			Insecure:           cfg.tlsInsecure,
			InsecureSkipVerify: cfg.tlsInsecureSkipVerify,
			Config: configtls.Config{
				KeyFile:  cfg.tlsKeyFile,
				CertFile: cfg.tlsCertFile,
				CAFile:   cfg.tlsCAFile,
			},
		},
	}

	// Use of slice instead of a concurrent goroutine to reduce memory usage.
	agents := make([]*agent.Agent, 0, cfg.scaleCount)
	var err error
	for range cfg.scaleCount {
		select {
		case <-ctx.Done():
			return agents, err
		default:
		}

		opts := []agent.Option{
			agent.WithAgentType(cfg.agentType),
			agent.WithAgentVersion(cfg.agentVersion),
		}
		if cfg.quietAgent {
			opts = append(opts, agent.WithLogger(nopLogger))
		}

		// Only pass in id and logger assocaited with id when running more than one agent.
		if cfg.scaleCount > 1 {
			id, err := uuid.NewV7()
			if err != nil {
				return nil, err
			}
			opts = append(opts,
				agent.WithNoClientCertRequest(),
				agent.WithInstanceID(id),
			)
			if !cfg.quietAgent {
				opts = append(opts, agent.WithLogger(agent.NewScaleLogger(id)))
			}
		}

		a := agent.NewAgent(agentConfig, opts...)
		if startErr := a.Start(); err != nil {
			err = errors.Join(err, startErr)
			continue
		}
		agents = append(agents, a)
	}
	return agents, err
}
